/*
 * Copyright (c) SuCraft 2022 sucraft.org
 */

package org.sucraft.modules.addpermissionstocommands

import com.sk89q.bukkit.util.CommandInspector
import com.sk89q.bukkit.util.DynamicPluginCommand
import com.sk89q.worldedit.extension.platform.Actor
import org.bukkit.Bukkit
import org.bukkit.command.PluginIdentifiableCommand
import org.bukkit.craftbukkit.v1_19_R1.CraftServer
import org.bukkit.permissions.PermissionDefault
import org.enginehub.piston.Command.Condition
import org.enginehub.piston.CommandManager
import org.enginehub.piston.inject.InjectedValueAccess
import org.enginehub.piston.inject.Key
import org.sucraft.common.module.SuCraftModule
import org.sucraft.common.scheduler.runLater
import org.sucraft.common.time.TimeInTicks
import java.util.*

/**
 * Adds Bukkit [operator][PermissionDefault.OP] Permissions to Commands that are only for operators,
 * but do not have a Bukkit permission set to them.
 */
object AddPermissionsToCommands : SuCraftModule<AddPermissionsToCommands>() {

	// Settings

	/**
	 * We attempt to add the Permissions multiple times after the server has started,
	 * because we would like them to be registered as soon as possible, but also must take into account there
	 * may be some plugins that register their Commands only at a later time (such as WorldEdit).
	 */
	val delaysAfterServerStartToPerformAttempt = arrayOf(
		TimeInTicks(1),
		TimeInTicks(21),
		TimeInTicks(101)
	)

	private const val overridePermissionPrefix = "override."

	/**
	 * Whether to print the Commands that do not have a permission that is at least limited to operators only,
	 * after the last attempt of adding Permissions, to the console.
	 */
	private const val logCommandsWithoutDefaultOperatorPermission = false

	// Implementation

	private fun attemptToAddPermissions() {
		val commandMap = Bukkit.getCommandMap()
		commandMap.knownCommands.values.distinct().forEach { command ->
			// Get the plugin of the command
			val plugin = (command as? PluginIdentifiableCommand)?.plugin
			// Ignore this command if it is not a command that is intended to be only for operators
			if (!((plugin != null && plugin.name.lowercase() in pluginNamesToProcessAllCommandsOf) ||
						command.name.lowercase() in commandLabelsToProcess)
			) return@forEach
			val existingPermission = command.permission?.let(Bukkit.getPluginManager()::getPermission)
			if (existingPermission == null || command is DynamicPluginCommand) {
				// If there is no existing permission, we create one
				// We always do this if the command is from WorldEdit or WorldGuard, because their
				// command class DynamicPluginCommand overrides the testPermissionSilent method and thereby
				// bypasses the normal Bukkit permission check: we always create a new permission for the command
				// and add it to their custom required permission list
				val newPermission = permission(
					"${overridePermissionPrefix}${plugin?.name?.lowercase() ?: "unknown"}" +
							".${command.name.lowercase()}",
					"Use the /${command.name.lowercase()} command",
					PermissionDefault.OP
				)
				if (existingPermission == null)
					command.permission = newPermission.key
				if (command is DynamicPluginCommand) {
					command.permissions =
						command.permissions?.let { it + arrayOf(newPermission.key) } ?: arrayOf(newPermission.key)
					// But wait, it gets worse!
					// Actually, the DynamicPluginCommand also has a registeredWith field, which may be an instance
					// of CommandInspector, in which case the permissions field is generally ignored, and the
					// CommandInspector is queried (from with testPermissionSilent) for whether someone has the
					// permission to the command - and it does this based on whether the version of the command
					// registered with a dispatcher has a condition that is satisfied if given an InjectedValueStore
					// with value Optional.of(plugin.wrapCommandSender(sender)) for key Key.of(Actor.class), so we
					// would like to modify this condition (which is not a field declared anywhere, but autogenerated
					// by some library annotation AutoValue.Builder) by also requiring our own condition (the sender
					// having our permission)
					if (command.registeredWith is CommandInspector) {
						// Based on BukkitCommandInspector.testPermission
						(org.joor.Reflect.on(command.registeredWith)
							.field("dispatcher")
							.get() as? CommandManager)?.let { commandManager ->
							commandManager.getCommand(command.name).orElse(null)?.let { mapping ->
								org.joor.Reflect.on(mapping).apply {
									val existingCondition = field("condition") as? Condition
									val newCondition = object : Condition {

										override fun satisfied(context: InjectedValueAccess): Boolean {
											context.injectedValue(Key.of(Actor::class.java))
												.orElse(null)
												?.run {
													if (!hasPermission(newPermission.key))
														return false
												} ?: return false
											return existingCondition?.satisfied(context) ?: true;
										}

										override fun toString() =
											"No permission"

									}
									set("condition", newCondition)
								}
							}
						}
					}
				}
			} else {
				// If there is an existing permission, we make sure it is limited to operators only
				// (We don't need to do anything if the permission default is already set to FALSE or OP)
				when (existingPermission.default) {
					PermissionDefault.TRUE, PermissionDefault.NOT_OP ->
						existingPermission.default = PermissionDefault.OP
					else -> {}
				}
			}
		}
	}

	private fun logCommandsWithoutDefaultOperatorPermission() {
		(Bukkit.getServer() as CraftServer).syncCommands()

		val commandMap = Bukkit.getCommandMap()
		val commandsWithoutPermission: SortedSet<String> = TreeSet()
		val commandsWithNonOperatorOnlyPermission: SortedMap<PermissionDefault, SortedSet<String>> = TreeMap()
		commandMap.knownCommands.forEach { (_, command) ->
			val permission = command.permission?.let(Bukkit.getPluginManager()::getPermission)
			val commandNameWithPlugin by lazy {
				"${(command as? PluginIdentifiableCommand)?.plugin?.name ?: "<minecraft>"}.${command.name}"
			}
			if (permission == null) {
				commandsWithoutPermission.add(commandNameWithPlugin)
			} else when (permission.default) {
				PermissionDefault.TRUE, PermissionDefault.NOT_OP ->
					commandsWithNonOperatorOnlyPermission.computeIfAbsent(permission.default) { TreeSet() }
						.add(commandNameWithPlugin)
				else -> {}
			}
		}

		sequenceOf(null, *commandsWithNonOperatorOnlyPermission.keys.toTypedArray()).forEach {
			val commandsToLog = it?.let(commandsWithNonOperatorOnlyPermission::getValue) ?: commandsWithoutPermission
			if (commandsToLog.isEmpty()) return@forEach
			info("Commands with ${it?.let { "default ${it.name.lowercase()}" } ?: "no"} permission:")
			@Suppress("NestedLambdaShadowedImplicitParameter")
			commandsToLog.forEach { info("* $it") }
		}

	}

	// Initialization

	override fun onInitialize() {
		super.onInitialize()
		// Schedule adding the Permissions
		delaysAfterServerStartToPerformAttempt.forEachIndexed { attempt, delay ->
			// Possibly print to console after the last attempt
			if (
				logCommandsWithoutDefaultOperatorPermission &&
				attempt == delaysAfterServerStartToPerformAttempt.lastIndex
			)
				runLater(delay) {
					attemptToAddPermissions()
					logCommandsWithoutDefaultOperatorPermission()
				}
			else
				runLater(
					delay,
					AddPermissionsToCommands::attemptToAddPermissions
				)
		}
	}

}